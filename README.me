# Mapeo de Direcciones Modbus - PLC HNC Serie HCS
**Modelo:** HCS-6X4Y-T  
**Configuración:** Modo "Soft Address" (Mapeo por bloques de 1024/512)

Este documento contiene las direcciones Modbus TCP/RTU confirmadas mediante barrido técnico para la integración con sistemas externos (Python, Django, SCADA).

## 1. Tabla de Direccionamiento (Modbus Decimal)

| Componente PLC | Dirección Inicial (DEC) | Dirección Inicial (HEX) | Tipo de Objeto Modbus | Función (FC) |
| :--- | :--- | :--- | :--- | :--- |
| **X (Entradas)** | 1024 | 0x0400 | Discrete Input | 02 |
| **Y (Salidas)** | 1536 | 0x0600 | Coil | 01, 05, 15 |
| **M (Memorias)** | 3072 | 0x0C00 | Coil | 01, 05, 15 |
| **CV (Contadores)**| 16384 | 0x4000 | Holding Register | 03, 06, 16 |
| **V / D (Datos)** | 512 | 0x0200 | Holding Register | 03, 06, 16 |

---

## 2. Detalles Técnicos de Implementación

### Entradas y Salidas (X / Y)
* **X0...X5:** Mapeadas a partir de la dirección **1024**. Son de solo lectura.
* **Y0...Y3:** Mapeadas a partir de la dirección **1536**. Permiten lectura y escritura.

### Memorias Internas (M)
* **M0:** Corresponde a la dirección **3072**. Es el punto de control ideal para banderas lógicas desde Python hacia el Ladder.

### Contadores (CV - Valor Actual)
* **CV0:** Ubicado en la dirección **16384**. 
* **Nota sobre 32 bits:** Si el contador es de alta velocidad (Double Word), consumirá dos registros (ej. 16384 y 16385). En Python se deben leer ambos y combinar: `(High << 16) + Low`.

---

## 3. Ejemplo de Conexión (Python - PyModbus)

```python
from pymodbus.client import ModbusTcpClient

# Configuración
PLC_IP = '192.168.1.111'
client = ModbusTcpClient(PLC_IP, port=502)

# Lectura de Salidas (Y)
salidas = client.read_coils(1536, count=4, slave=1)

# Lectura de Totalizador (CV0)
contador = client.read_holding_registers(16384, count=1, slave=1)

if not contador.isError():
    print(f"Valor actual del pozo: {contador.registers[0]}")

client.close()